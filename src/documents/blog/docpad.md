---
layout: page
title: Создание профессиональных сайтов с помощью DocPad
---
Когда я только начинал работу над сайтом [документации для Emmet](http://docs.emmet.io), мне предстояло выбрать, на чём его делать. Требования были следующие:

* Удобное добавление новых разделов сайта.
* Простое редактирование документов, желательно с помощью Markdown или Textile.
* Удобное резервное копирование и восстановление данных.
* Так как для английский — не родной язык, желательно дать возможность читателям самим исправлять ошибки в тексте.
* Возможность оптимизации загрузки веб-страниц и автоматический деплой.
* Низкое потребление системных ресурсов: проект бесплатный, а мне не хочется тратиться на дополнительные серверы, когда на сайт зайдёт много народу.

По этим причинам обычные решения вроде Wordpress или популярные CMS меня не устраивали. Так как сайт не очень большой, для этих целей прекрасно подходят _генераторы статических сайтов_: результатом их работы является набор статических HTML-файлов, но при этом можно пользоваться преимуществом динамических сайтов вроде шаблонов и препроцессоров.

Беглый осмотр движков для генерации сайтов показал, что ни один из них не удовлетворяет моих потребностей, поэтому нужно выбрать какой-нибудь один движок и дописать для несколько плагинов. За основу я взял [DocPad](https://docpad.org): у него отличная архитектура и он написан на CoffeeScript, что мне, как фронт-энд разработчику, гораздо ближе и понятнее, чем, например, Ruby или Python. Движок прекрасно расширяется плагинами, написанными на CoffeeScript или JavaScript.

## Начало работы с DocPad

Я не будут писать про азы работы с DocPad, они прекрасно описаны на [официальном сайте](http://docpad.org/docs/intro). Если коротко, то исходник сайта храниться в папке `src`, внутри которой находятся следующие папки:

* `layouts` — шаблоны сайта
* `documents` — страницы сайта
* `files` — различные статические файлы вроде CSS, JS и картинок.

После сборки создаётся специальная папка (по умолчанию это `out`), в которой находятся сгенерированные HTML-страницы сайта и статические файлы.

У DocPad, как и у многих других генераторов, есть следующие недостатки:

* Он не умеет создавать меню сайта с автоматическим выделением текущего/родительского элемента. Многие разработчики решают эту проблему статическим списком в шаблоне и проверкой URL текущего документа. Это может сработать, если у вас на сайте 3–4 страницы, но не несколько десятков.
* Нет возможности управлять наборами CSS и JS файлов. Например, мне бы хотелось в базовом шаблоне задать основные CSS и JS библиотеки, которые используются на каждой странице, но на некоторых страницах добавить свои файлы или даже перекрыть некоторые файлы из базового набора.
* Нет возможности управления кэшированием JS и CSS файлов. Для максимальной производительности нужно отдавать эти файлы с правильными кэширующими заголовками, но также нужно автоматически сбрасывать кэш, если файл поменялся. Обычно это решается добавлением, например, даты последнего изменения файла в его URL: `/20130116162044/css/main.css`.

Для решения этих проблем я и написал несколько плагинов.

### Генерация меню

Начнём с меню. Плагин `[docpad-plugin-menu](https://github.com/sergeche/docpad-plugin-menu)` умеет геренировать структурированное меню для всех страниц сайта (то есть для всех файлов из папки `src/documents`). Этот плагин добавляет метод `generateMenu(url)` в объект `templateData` (в контексте этого объекта отрисовываются все шаблоны проекта). На вход этот метод принимает URL страницы, относительно которой нужно создать меню, на выходе вы получите структуру разделов сайта, которую удобно отрисовывать, например, с помощью [partials](https://github.com/docpad/docpad-plugin-partials/).

Подробнее о возможностях плагина и примерах его использования читайте на [основной странице проекта](https://github.com/sergeche/docpad-plugin-menu#readme).

### Сборка фронт-энд ресурсов

Для удобства разработки я разбиваю CSS и JS файлы на отдельные модули, которые затем склеиваются и минифицируются. Для сборки я использую [Grunt.js](http://gruntjs.com) в котором, казалось бы, уже есть все необходимые инструменты для выполнения этих задач.

Но и тут я не нашёл ничего подходящего. Дело в том, что мне важна *дата последнего обновления* минифицированного файла, потому что я хочу её подставлять в URL файла для эффективного сброса кэша. Поэтому обновлять конечный файл нужно только тогда, когда поменялся один исходных файлов.

Для решения этой задачи я написал свой сборщик: [grunt-frontend](https://github.com/sergeche/grunt-frontend). Работает он следующим образом. Во время конкатенации и минификации нескольких файлов в один он записывает структуру исходных файлов и их md5-отпечаток в специальный файл `.build-catalog.json`. При следующей сборке плагин смотрит на структуру и содержимое исходных файлов: если ничего не поменялось, то и конечный файл не минифицируется и не обновляется. 

Это не только сокращает время сборки, но и позволяет сохранить такие важные данные конечного файла как дату обновления и md5-отпечаток. Все эти данные хранятся в `.build-catalog.json`, его желательно хранить вне версионного контроля.

Для минификации используются библиотеки [CSSO](https://github.com/css/csso) (с автоматическим инлайнингом всех подключённых через `@import` файлов) и [UglifyJS](https://github.com/mishoo/UglifyJS).

Подробнее об использовании `grunt-frontend`: https://github.com/sergeche/grunt-frontend

### Управление CSS и JS ресурсами

Очень часто возникает необходимость управлять подключением CSS и JS файлов на различные страницы сайта. Скажем, на всех страницах сайта нужно использовать набор файлов `set1`; для всех внутренних страниц раздела `/about/` нужно дополнительно использовать `set2` и `set3`, но для страницы `/about/contacts/` вместо `set2` нужно использовать `set4` (то есть `set1`, `set4`, `set3`, именно в таком порядке). Кроме того, в URL всех ресурсов  нужно подставлять дату модификации файла чтобы эффективно сбрасывать кэш.

Для решения этих задач был написан плагин `[docpad-plugin-frontend](https://github.com/sergeche/docpad-plugin-frontend)`. Этот плагин добавляет метод `assets(prefix)`, который позволяет доставать отсортированный список ресурсов из текущего документа и всей цепочки шаблонов. Если в корневой папке проекта существует файл `.build-catalog.json`, то плагин считывает этот этот файл и возвращает список ресурсов с префиксом в виде даты модификации файла.

Например, описанную выше задачу с управлением наборов ресурсов можно решить следующим образом. Для основного шаблона `default.html.eco` указываем основной набор файлов в мета-данных:

    ---
    js: "/js/fileA.js"
    ---

В шаблоне `about.html.eco`, который наследуется от основного шаблона и применяется ко всем документам `/about/*`, указываем следующие данные:

    ---
    layout: default
    js2: ["/js/fileB.js", "/js/fileC.js"]
    js3: ["/js/fileD.js", "/js/fileE.js"]
    ---

В документе `/about/contacts/index.html` перекрываем набор `js2`:

    ---
    layout: about
    js2: "/js/contacts.js"
    ---

Теперь, при рендеринге страницы `/about/contacts/index.html`, вызов `assets('js')` вернёт следующий набор файлов:

* `/js/fileA.js`
* `/js/contacts.js`
* `/js/fileD.js`
* `/js/fileE.js`

Как видите, всё довольно просто: придумываем префикс для категории ресурсов, а сами наборы создаём с помощью числовых суффиксов. Далее вызываем `assets()` в шаблоне и передаём ему префикс набора ресурсов: файлы сортируются по суффиксу в порядке возрастания; наборы с одинаковым суффиксом перекрываются.

Более подробную информацию о возможностях плагина и примерах использования читайте на [главной странице репозитория](https://github.com/sergeche/docpad-plugin-frontend#readme).

### Режим отладки

Очень часто бывает так, что пользователь вашего сайта пишет вам, что в каком-то браузере возникает ошибка: не работает JavaScript или элементы наехали друг на друга. Но весь ваш CSS и JS код минифициорван и вам довольно сложно найти то самое место в _исходных файлах_, где ошибка возникает.

В будущем эти проблемы можно будет находить с помощью [Source Maps](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/), но сейчас далеко не все минификаторы и браузеры их поддерживают.

В плагине `docpad-plugin-frontend` есть специальный режим отладки. Так как структура всех минифицированных файлов хранится в JSON-каталоге, нам не составит труда при необходимости вывести список исходных файлов вместо скомпилированного. 

Для этого в DocPad я создаю отдельное _окружение_, в котором указываю опцию `frontendDebug: true`. Если опция `frontendDebug` равна `true`, то метод `assets()` плагина `docpad-plugin-frontend` будет по возможности возвращать список исходных файлов вместо минифицированных. Пример настройки `docpad.coffee`:

    module.exports = {
        …
        environments:
            debug:
                frontendDebug: true
    }

Теперь при запуске `DocPad` в окружением `debug`, вы получите HTML-страницы с исходными CSS и JS файлами и сможете легко найти ошибку:

    docpad run --env=debug

### Автоматический деплой с GitHub

Я настроил сервер таким образом, чтобы после каждого коммита в ветку `master` сайт автоматически генерировался.

Со стороны GitHub я использовал обычный “WebHook”, а на стороне сервера – [Gith](http://weblog.bocoup.com/introducing-gith-github-webhooks-for-node/).

Gith – это удобный веб-сервер для Node.JS, который умеет принимать и фильтровать данные веб-хуков GitHub. Мой сервер, который запускает сборку сайта, выглядит следующим образом:

	var childProc = require('child_process');
	var path = require('path');
	
	var gith = require('gith').create(3000);
	
	gith({
		// Слушаем хуки только для ветки "master"
		branch: 'master'
	}).on('all', function(payload) {
		console.log('Run deply script on', new Date());
	
		// Запускаем скрипт сборки сайта
		var deploy = childProc.spawn('sh', ['/web/deploy.sh']);
	
		deploy.stdout.on('data', function(data) {
			var message = data.toString('utf8');
			console.log(message);
	
			if (~message.indexOf('subscribe')) {
				// Docpad может спросить про подписку на рассылку, откажемся
				deploy.stdin.write('n');
			} else if (~message.toLowerCase().indexOf('privacy')) {
				// Docpad может спросить про политику безопасности, согласимся
				deploy.stdin.write('y');
			}
		});
	
		deploy.stderr.on('data', function(data) {
			console.log('Error: ', data.toString('utf8'));
		});
	
		deploy.on('exit', function(code) {
			console.log('Deploy complete with exit code ' + code);
		});
	});
	
Сам скрипт сборки проекта `deploy.sh` выглядит следующим образом:

	#! /usr/bin/env bash
	git pull
	git submodule foreach 'git checkout master && git pull origin master'
	npm install
	grunt
	docpad generate
	find ./out -type f \( -name '*.html' -o -name '*.css' -o -name '*.js' \)  -exec sh -c "gzip -7 -f < {} > {}.gz" \;
	
### Настройка nginx

В качестве веб-сервера я использую [nginx](http://nginx.org), который прекрасно оптимизирован для отдачи статики. В настройках сайта нам нужно сделать следующее:

* Прописать рерайты для статических файлов: отсекать дату модификации в начале пути и посылать правильные кэширующие заголовки.
* Отдавать статику в gzip для снижения объёма передаваемых файлов.

Если посмотреть на скрипт `deploy.sh`, то вы увидите, что в последнем шаге создаются gzip-версии всех HTML, CSS и JS файлов. У nginx есть специальный модуль [HttpGzipStaticModule](http://wiki.nginx.org/HttpGzipStaticModule), который может отдавать заранее созданные gzip-версии файлов вместо автоматической генерации для каждого запроса. Этот трюк позволит нам сэкономить процессорные ресурсы. Для того, чтобы воспользоваться этим модулем, его нужно добавить в nginx при компиляции:

	./configure --with-http_gzip_static_module
	
Мой конфиг nginx выглядит так:

	server {
		server_name  your-server.com;
		root         /path/to/web-site/out;
	
		index  index.html index.htm;
	
		# отсекаем дату модификации со статических ресурсов
		location ~* ^/\d+/(css|js)/ {
			rewrite ^/(\d+)/(.*)$ /$2;
		}
	
		# кэшируем всё статику
		location ~* \.(?:ico|css|js|gif|jpe?g|png)$ {
			expires max;
			access_log off;
			add_header Pragma public;
			add_header Cache-Control "public";
		}
	
		# включаем поддержку статических gzip-версий файлов
		gzip_static on;
	}
	
## tl;dr – Как сделать профессиональный высокопроизводительный сайт на DocPad

* Используйте плагин [docpad-plugin-menu](https://github.com/sergeche/docpad-plugin-menu) для автоматической генерации меню сайта.
* Используйте [grunt-frontend](https://github.com/sergeche/grunt-frontend) и [docpad-plugin-frontend](https://github.com/sergeche/docpad-plugin-frontend) для сборки CSS и JS ресурсов и правильного кэширования.
* Создайте специальное debug-окружение для плагина `docpad-plugin-frontend` для поиска проблем в исходниках CSS и JS, а не им минифицированных версиях.
* Настройте веб-хуки на GitHub и [Gith](http://weblog.bocoup.com/introducing-gith-github-webhooks-for-node/) на сервере для автоматической сборки сайта после каждого коммита.
* Настройке nginx для правильного кэширования статических файлов и экономии ресурсов процессора.